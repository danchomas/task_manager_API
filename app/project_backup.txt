
==================== api/tasks_routers.py ====================
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from uuid import UUID

from schemas.tasks_schemas import TaskSchema, TaskCreateSchema, TaskUpdateSchema
from services.tasks_services import TaskCreateManager, TaskGetManager, TaskUpdateManager, TaskDeleteManager
from core.database import get_db

router = APIRouter()

@router.post("/", response_model=TaskSchema, status_code=status.HTTP_201_CREATED)
def create_task_endpoint(task: TaskCreateSchema, db: Session = Depends(get_db)):
    task_manager = TaskCreateManager(db)
    return task_manager.create_task(task)


@router.get("/{task_id}", response_model=TaskSchema)
def get_task_endpoint(task_id: UUID, db: Session = Depends(get_db)):
    task_manager = TaskGetManager(db)
    db_task = task_manager.get_task(task_id)
    if db_task is None:
        raise HTTPException(status_code=404, detail="Task not found")
    return db_task


@router.get("/", response_model=List[TaskSchema])
def get_tasks_endpoint(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    task_manager = TaskGetManager(db)
    return task_manager.get_tasks(skip, limit)


@router.put("/{task_id}", response_model=TaskSchema)
def update_task_endpoint(task_id: UUID, task: TaskUpdateSchema, db: Session = Depends(get_db)):
    task_manager = TaskUpdateManager(db)
    db_task = task_manager.update_task(task_id, task)
    if db_task is None:
        raise HTTPException(status_code=404, detail="Task not found")
    return db_task


@router.delete("/{task_id}", response_model=TaskSchema)
def delete_task_endpoint(task_id: UUID, db: Session = Depends(get_db)):
    task_manager = TaskDeleteManager(db)
    db_task = task_manager.delete_task(task_id)
    if db_task is None:
        raise HTTPException(status_code=404, detail="Task not found")
    return db_task


==================== api/user_routers.py ====================
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from uuid import UUID
from typing import List

from schemas.user_schemas import UserCreateSchema, UserLoginSchema, UserSchema
from services.user_services import UserCreateManager, UserLoginManager, UserGetManager
from core.database import get_db

router = APIRouter()

@router.get("/", response_model=List[UserSchema])
def get_all_users_endpoint(db: Session = Depends(get_db)):
    user_manager = UserGetManager(db)
    return user_manager.get_all_users()

@router.post("/authorization", response_model=UserSchema, status_code=status.HTTP_201_CREATED)
def create_user_endpoint(user: UserCreateSchema, db: Session = Depends(get_db)):
    user_manager = UserCreateManager(db)
    return user_manager.create_user(user)

@router.get("/{user_id}", response_model=UserSchema)
def get_user_endpoint(user_id: UUID, db: Session = Depends(get_db)):
    user_manager = UserGetManager(db)
    db_user = user_manager.get_user(user_id)
    if db_user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return db_user

@router.post("/login", response_model=UserSchema)
def login_user_endpoint(credentials: UserLoginSchema, db: Session = Depends(get_db)):
    user_manager = UserLoginManager(db)
    db_user = user_manager.login_user(
        credentials.username,
        credentials.password
    )
    if db_user is None:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    return db_user


==================== copy_project.py ====================
#!/usr/bin/env python3
import os
from pathlib import Path

def collect_project_files(project_root, ignore_patterns):
    """Собирает все файлы проекта, исключая указанные паттерны."""
    project_files = []

    for root, dirs, files in os.walk(project_root):
        # Удаляем игнорируемые директории
        dirs[:] = [d for d in dirs if not should_ignore_dir(d, ignore_patterns)]

        for file in files:
            if not should_ignore_file(file, ignore_patterns):
                file_path = Path(root) / file
                relative_path = file_path.relative_to(project_root)
                project_files.append(relative_path)

    return sorted(project_files)

def should_ignore_dir(dir_name, ignore_patterns):
    """Проверяет, нужно ли игнорировать директорию."""
    ignore_dirs = [
        '__pycache__', '.git', '.idea', '.vscode', 'venv', 'env', '.venv',
        'build', 'dist', '.eggs', '*.egg-info'
    ]
    return dir_name in ignore_dirs

def should_ignore_file(file_name, ignore_patterns):
    """Проверяет, нужно ли игнорировать файл."""
    ignore_files = [
        '*.pyc', '*.pyo', '*.pyd', '.DS_Store', '*.log', '.gitignore',
        '.env', '*.tmp', '*.swp', '*.swo', 'Thumbs.db', '*.so', '*.dll'
    ]

    for pattern in ignore_files:
        if pattern.startswith('*.'):
            if file_name.endswith(pattern[1:]):
                return True
        else:
            if file_name == pattern:
                return True
    return False

def read_file_content(file_path):
    """Читает содержимое файла, если это текстовый файл."""
    try:
        # Пробуем открыть как текстовый файл
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    except (UnicodeDecodeError, PermissionError):
        return "[Бинарный файл или файл недоступен для чтения]"

def main():
    # Путь к текущей директории (корень проекта)
    project_root = Path(__file__).parent.resolve()

    # Имя выходного файла
    output_file = project_root / "project_backup.txt"

    print("Собираю список файлов проекта...")

    # Собираем все файлы проекта
    ignore_patterns = []  # Можно расширить при необходимости
    project_files = collect_project_files(project_root, ignore_patterns)

    print(f"Найдено файлов: {len(project_files)}")
    print("Записываю данные в файл...")

    # Записываем всё в текстовый файл
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(f"=== РЕЗЕРВНАЯ КОПИЯ ПРОЕКТА ===\n")
        f.write(f"Путь к проекту: {project_root}\n")
        f.write(f"Дата создания: {os.path.getctime(__file__)}\n")
        f.write(f"Всего файлов: {len(project_files)}\n")
        f.write("=" * 50 + "\n\n")

        for file_path in project_files:
            full_path = project_root / file_path
            f.write(f"\n{'='*20} {file_path} {'='*20}\n")

            # Читаем содержимое файла
            content = read_file_content(full_path)
            f.write(content)
            f.write("\n")

    print(f"Резервная копия создана: {output_file}")

if __name__ == "__main__":
    main()


==================== core/__init__.py ====================


==================== core/database.py ====================
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session, declarative_base

SQLALCHEMY_DATABASE_URL = "sqlite:///./task_manager.db"

engine = create_engine(SQLALCHEMY_DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()


def get_db() -> Session:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


==================== main.py ====================
from fastapi import FastAPI
from api.tasks_routers import router as tasks_router
from api.user_routers import router as user_router
from core.database import engine, Base
import uvicorn

Base.metadata.create_all(bind=engine)

app = FastAPI(
    title="Task Manager API",
    description="A simple task manager API",
    version="0.0.1",
    docs_url="/docs",
    openapi_security=[{
        "BearerAuth": []
    }]
)
app.include_router(tasks_router, prefix="/tasks", tags=["tasks"])
app.include_router(user_router, prefix="/users", tags=["users"])


if __name__ == "__main__":
    uvicorn.run('main:app', host="127.0.0.1", port=8000, reload=True)


==================== models/__init__.py ====================


==================== models/tasks_models.py ====================
import uuid
from sqlalchemy import Column, String, Enum as SQLEnum, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import UUID
from core.database import Base
from enum import Enum


class TaskStatus(Enum):
    CREATED = "created"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"


class Task(Base):
    __tablename__ = "tasks"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, index=True)
    name = Column(String, index=True)
    description = Column(String)
    status = Column(SQLEnum(TaskStatus, name="taskstatus", values_callable=lambda x: [e.value for e in x]), default=TaskStatus.CREATED)
    user_id = Column(UUID, ForeignKey("users.id"))

    user = relationship("User", back_populates="tasks")


==================== models/user_models.py ====================
from sqlalchemy import Column, String, UUID, DateTime
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
import uuid
from core.database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String, unique=True, nullable=False)
    username = Column(String, unique=True, nullable=False)
    password = Column(String, nullable=False)
    created_at = Column(DateTime, server_default=func.now())

    tasks = relationship("Task", back_populates="user")


==================== schemas/__init__.py ====================


==================== schemas/tasks_schemas.py ====================
from pydantic import BaseModel, UUID4, ConfigDict
from enum import Enum
from typing import Optional


class TaskStatusSchema(str, Enum):
    CREATED = "created"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"


class TaskBase(BaseModel):
    name: str
    description: Optional[str] = None
    status: TaskStatusSchema = TaskStatusSchema.CREATED


class TaskCreateSchema(TaskBase):
    pass


class TaskUpdateSchema(TaskBase):
    name: Optional[str] = None
    description: Optional[str] = None
    status: Optional[TaskStatusSchema] = None


class TaskSchema(TaskBase):
    id: UUID4

    model_config = ConfigDict(from_attributes=True)


==================== schemas/user_schemas.py ====================
from pydantic import BaseModel, EmailStr, Field, field_validator, ConfigDict
from uuid import UUID
from datetime import datetime
import re

class UserBase(BaseModel):
    username: str = Field(
        min_length=4,
        max_length=20
    )
    email: EmailStr

    @field_validator('username')
    @classmethod
    def validate_username(cls, value: str) -> str:
        if not re.match(r"^[a-zA-Z0-9_]+$", value):
            raise ValueError('Username must contain only letters, numbers, and underscores')
        return value


class UserCreateSchema(UserBase):
    username: str = Field(
        min_length=4,
        max_length=20
    )
    password: str = Field(
        min_length=5
    )

    @field_validator('password')
    @classmethod
    def validate_password(cls, value: str) -> str:
        pattern = r"^[A-Za-z\d@$!%*?&]{5,}$"
        if not re.match(pattern, value):
            raise ValueError(
                'Password must be at least 5 characters long and contain: '
                'only letters, numbers, and special characters (@$!%*?&)'
            )
        return value


class UserLoginSchema(BaseModel):
    username: str
    password: str


class UserSchema(UserBase):
    id: UUID
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


==================== services/__init__.py ====================


==================== services/tasks_services.py ====================
from sqlalchemy.orm import Session
from models.tasks_models import Task
from schemas.tasks_schemas import TaskCreateSchema, TaskUpdateSchema
from uuid import UUID


class TaskRepository:
    def __init__(self, db: Session):
        self.db = db

    def get_task(self, task_id: UUID) -> Task | None:
        return self.db.query(Task).filter(Task.id == task_id).first()

class TaskCreateManager(TaskRepository):
    def create_task(self, task: TaskCreateSchema) -> Task:
        db_task = Task(**task.model_dump())
        self.db.add(db_task)
        self.db.commit()
        self.db.refresh(db_task)
        return db_task

class TaskGetManager(TaskRepository):
    def get_tasks(self, skip: int = 0, limit: int = 100) -> list[Task]:
        return self.db.query(Task).offset(skip).limit(limit).all()

class TaskUpdateManager(TaskRepository):
    def update_task(self, task_id: UUID, task: TaskUpdateSchema) -> Task | None:
        db_task = self.get_task(task_id)
        if db_task:
            update_data = task.model_dump(exclude_unset=True)
            for key, value in update_data.items():
                setattr(db_task, key, value)
        self.db.commit()
        self.db.refresh(db_task)
        return db_task

class TaskDeleteManager(TaskRepository):
    def delete_task(self, task_id: UUID) -> Task | None:
        db_task = self.get_task(task_id)
        if db_task:
            self.db.delete(db_task)
            self.db.commit()
        return db_task


==================== services/user_services.py ====================
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from models.user_models import User
from schemas.user_schemas import UserCreateSchema
from uuid import UUID
from fastapi import HTTPException, status

class UserCreateManager:
    def __init__(self, db: Session):
        self.db = db

    def create_user(self, user: UserCreateSchema) -> User:
        existing_user = self.db.query(User).filter(
            (User.email == user.email) | (User.username == user.username)
        ).first()

        if existing_user:
            if existing_user.email == user.email:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Email already registered"
                )
            else:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Username already taken"
                )
        db_user = User(
            email=user.email,
            username=user.username,
            password=user.password
        )
        try:
            self.db.add(db_user)
            self.db.commit()
            self.db.refresh(db_user)
            return db_user
        except IntegrityError:
            self.db.rollback()
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="User already exists"
            )

class UserGetManager:
    def __init__(self, db: Session):
        self.db = db

    def get_user(self, user_id: UUID) -> User:
        return self.db.query(User).filter(User.id == user_id).first()

    def get_all_users(self) -> list[User]:
        return self.db.query(User).all()

class UserLoginManager:
    def __init__(self, db: Session):
        self.db = db

    def login_user(self, username: str, password: str) -> User:
        user = self.db.query(User).filter(User.username == username).first()
        if user and user.password == password:
            return user
        return None


==================== task_manager.db ====================
[Бинарный файл или файл недоступен для чтения]

==================== tests/conftest.py ====================
# tests/conftest.py
import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import StaticPool

from app.database import Base, get_db
from main import app

SQLALCHEMY_DATABASE_URL = "sqlite:///:memory:"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL,
    connect_args={"check_same_thread": False},
    poolclass=StaticPool,
)
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

@pytest.fixture(scope="function")
def test_db():
    Base.metadata.create_all(bind=engine)
    db = TestingSessionLocal()
    try:
        yield db
    finally:
        db.close()
        Base.metadata.drop_all(bind=engine)

@pytest.fixture(scope="function")
def client(test_db):
    def override_get_db():
        try:
            yield test_db
        finally:
            test_db.close()

    app.dependency_overrides[get_db] = override_get_db
    with TestClient(app) as test_client:
        yield test_client
    app.dependency_overrides.clear()


==================== tests/test_tasks.py ====================
# tests/test_tasks.py
import pytest
from uuid import UUID, uuid4

def test_create_task(client):
    response = client.post(
        "/tasks/",
        json={"name": "Test Task", "description": "Test Description"}
    )
    assert response.status_code == 201
    data = response.json()
    assert data["name"] == "Test Task"
    assert data["description"] == "Test Description"
    assert data["status"] == "created"
    assert UUID(data["id"])

def test_get_task(client):
    create_response = client.post(
        "/tasks/",
        json={"name": "Test Task"}
    )
    task_id = create_response.json()["id"]

    response = client.get(f"/tasks/{task_id}")
    assert response.status_code == 200
    data = response.json()
    assert data["id"] == task_id
    assert data["name"] == "Test Task"

def test_get_nonexistent_task(client):
    response = client.get(f"/tasks/{uuid4()}")
    assert response.status_code == 404

def test_get_tasks(client):
    for i in range(3):
        client.post("/tasks/", json={"name": f"Task {i}"})

    response = client.get("/tasks/")
    assert response.status_code == 200
    data = response.json()
    assert len(data) == 3

def test_update_task(client):
    create_response = client.post("/tasks/", json={"name": "Original Task"})
    task_id = create_response.json()["id"]

    update_response = client.put(
        f"/tasks/{task_id}",
        json={"name": "Updated Task", "status": "in_progress"}
    )
    assert update_response.status_code == 200
    data = update_response.json()
    assert data["name"] == "Updated Task"
    assert data["status"] == "in_progress"

def test_update_nonexistent_task(client):
    response = client.put(
        f"/tasks/{uuid4()}",
        json={"name": "Updated Task"}
    )
    assert response.status_code == 404

def test_delete_task(client):
    create_response = client.post("/tasks/", json={"name": "To be deleted"})
    task_id = create_response.json()["id"]

    delete_response = client.delete(f"/tasks/{task_id}")
    assert delete_response.status_code == 200

    get_response = client.get(f"/tasks/{task_id}")
    assert get_response.status_code == 404

def test_delete_nonexistent_task(client):
    response = client.delete(f"/tasks/{uuid4()}")
    assert response.status_code == 404

def test_invalid_status(client):
    response = client.post(
        "/tasks/",
        json={"name": "Test", "status": "invalid_status"}
    )
    assert response.status_code == 422
